<!DOCTYPE HTML><html><head><meta charset="utf-8"><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>多个AspectJ对同一个对象操作产生的实际效果以及顺序情况 | WhatAKitty Daily | A Programmer&#39;s Daily Record</title><meta name="author" content="WhatAKitty"><meta name="description" content="Just A Simple Programmer."><meta name="keywords" content="AOP,java,Spring,Spring5,CGLIB,AspectJ,dynamic,bean post,Blog, SSL, Nodejs, DevOps, Spring, Spring Cloud, Jenkins, Docker, JIRA, CI"><meta id="viewport" name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1,user-scalable=no,minimal-ui"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta property="og:title" content="多个AspectJ对同一个对象操作产生的实际效果以及顺序情况"><meta property="og:site_name" content="WhatAKitty Daily"><meta property="og:image" content="/favicon.ico"><link href="/favicon.ico" rel="icon"><link rel="alternate" href="/atom.xml" title="WhatAKitty Daily" type="application/atom+xml"><link rel="stylesheet" href="/css/style.css" media="screen" type="text/css"></head><body><div class="blog"><div class="content"><header><div class="site-branding"><h1 class="site-title"><a href="/">WhatAKitty Daily</a></h1><p class="site-description">A Programmer&#39;s Daily Record</p></div><nav class="site-navigation"><ul><li><a href="/">主页</a></li><li><a href="/archives">归档</a></li><li><a href="/projects">项目</a></li><li><a href="/categories/JavaSources">Java Sources</a></li><li><a href="/atom.xml">订阅</a></li></ul></nav></header><main class="site-main posts-loop"><article><h3 class="article-title"><span>多个AspectJ对同一个对象操作产生的实际效果以及顺序情况</span></h3><div class="article-top-meta"><span class="posted-on"><a href="/多个AspectJ对同一个对象操作产生的实际效果以及顺序情况.html" rel="bookmark">WhatAKitty &emsp; <time class="entry-date published" datetime="2018-08-20T15:11:39.000Z">2018-08-20</time></a></span></div><div class="article-content"><div class="entry"><h3 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h3><ul><li>Spring 5</li><li>基于Java Configuration配置，而非XML配置</li><li>对于AspectJ的分析，不对Spring本身的Advisor做分析</li></ul><h3 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h3><p>如果需要了解多个AscpectJ对同一个对象操作产生的实际效果以及作用顺序，则需要首先了解AOP对象的构建过程，以及如何织入，还有就是织入过程中的顺序逻辑的了解。</p><p>所以，这篇文章主要内容如下：</p><ul><li><a href="#AOP构造者注册">AOP构造者注册</a></li><li><a href="#AOP代理对象的初始化构建">AOP代理对象的初始化构建</a></li><li><a href="#AOP%20advice的顺序问题">AOP advice的顺序问题</a></li><li><a href="#AOP%20advice的具体调用">AOP advice的具体调用</a></li></ul><a id="more"></a><h3 id="AOP构造者注册"><a href="#AOP构造者注册" class="headerlink" title="AOP构造者注册"></a>AOP构造者注册</h3><p>AOP构造者的注册是通过Spring的Import机制实现。在<code>EnableAspectJAutoProxy</code>注解上，存在@Import注解，其内部有实现了<code>ImportBeanDefinitionRegistrar</code>接口的<code>AspectJAutoProxyRegistrar</code>类。</p><p>在这里简单介绍下<code>ImportBeanDefinitionRegistrar</code>接口。</p><p><code>ImportBeanDefinitionRegistrar</code>接口常被用于Spring动态bean注册。这个接口会被<code>ConfigurationClassPostProcessor</code>类内的<code>ConfigurationClassParser</code>代理类解析，并通过<code>ConfigurationClassBeanDefinitionReader</code>类的<code>loadBeanDefinitions</code>方法调用所有实现了<code>ImportBeanDefinitionRegistrar</code>接口类的<code>registerBeanDefinitions</code>方法。</p><p>以下是<code>ImportBeanDefinitionRegistrar</code>类执行<code>registerBeanDefinitions</code>的过程：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 容器上下文注册</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AnnotationConfigApplicationContext</span><span class="params">(Class&lt;?&gt;... annotatedClasses)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>();</span><br><span class="line">  register(annotatedClasses);</span><br><span class="line">  <span class="comment">// 刷新</span></span><br><span class="line">  refresh();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 执行invokeBeanFactoryPostProcessors</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 执行PostProcessor代理类的invokeBeanFactoryPostProcessors方法</span></span><br><span class="line">PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 循环所有的beanProcessors</span></span><br><span class="line"><span class="keyword">for</span> (BeanDefinitionRegistryPostProcessor postProcessor : postProcessors) &#123;</span><br><span class="line">  postProcessor.postProcessBeanDefinitionRegistry(registry);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 执行ConfigurationClassPostProcessor类的postProcessBeanDefinitionRegistry方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">  processConfigBeanDefinitions(registry);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6. 实例化ConfigurationClassParser类，并执行解析操作（比如@PropertySources、@ComponentScans、@Import、@ImportSelectors等等注解的解析处理）</span></span><br><span class="line">ConfigurationClassParser parser = <span class="keyword">new</span> ConfigurationClassParser(</span><br><span class="line">				<span class="keyword">this</span>.metadataReaderFactory, <span class="keyword">this</span>.problemReporter, <span class="keyword">this</span>.environment,</span><br><span class="line">				<span class="keyword">this</span>.resourceLoader, <span class="keyword">this</span>.componentScanBeanNameGenerator, registry);</span><br><span class="line"></span><br><span class="line">Set&lt;BeanDefinitionHolder&gt; candidates = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(configCandidates);</span><br><span class="line">parser.parse(candidates);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 7. 加载Bean解析信息</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.reader == <span class="keyword">null</span>) &#123;</span><br><span class="line">  <span class="keyword">this</span>.reader = <span class="keyword">new</span> ConfigurationClassBeanDefinitionReader(</span><br><span class="line">      registry, <span class="keyword">this</span>.sourceExtractor, <span class="keyword">this</span>.resourceLoader, <span class="keyword">this</span>.environment,</span><br><span class="line">      <span class="keyword">this</span>.importBeanNameGenerator, parser.getImportRegistry());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>.reader.loadBeanDefinitions(configClasses);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 8. 从配置类加载Bean解析信息</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitionsForConfigurationClass</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">			ConfigurationClass configClass, TrackedConditionEvaluator trackedConditionEvaluator)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (trackedConditionEvaluator.shouldSkip(configClass)) &#123;</span><br><span class="line">    String beanName = configClass.getBeanName();</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasLength(beanName) &amp;&amp; <span class="keyword">this</span>.registry.containsBeanDefinition(beanName)) &#123;</span><br><span class="line">      <span class="keyword">this</span>.registry.removeBeanDefinition(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.importRegistry.removeImportingClass(configClass.getMetadata().getClassName());</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (configClass.isImported()) &#123;</span><br><span class="line">    registerBeanDefinitionForImportedConfigurationClass(configClass);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (BeanMethod beanMethod : configClass.getBeanMethods()) &#123;</span><br><span class="line">    loadBeanDefinitionsForBeanMethod(beanMethod);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  loadBeanDefinitionsFromImportedResources(configClass.getImportedResources());</span><br><span class="line">  <span class="comment">// 加载Import registry的信息</span></span><br><span class="line">  loadBeanDefinitionsFromRegistrars(configClass.getImportBeanDefinitionRegistrars());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">9</span>. ImportBeanDefinitionRegistrar执行bean解析</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitionsFromRegistrars</span><span class="params">(Map&lt;ImportBeanDefinitionRegistrar, AnnotationMetadata&gt; registrars)</span> </span>&#123;</span><br><span class="line">  registrars.forEach((registrar, metadata) -&gt;</span><br><span class="line">      registrar.registerBeanDefinitions(metadata, <span class="keyword">this</span>.registry));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p>
<p>在注册过程中，<code>ImportBeanDefinitionRegistrar</code>类先将<code>AnnotationAwareAspectJAutoProxyCreator</code>注册到了Bean容器内，然后通过<code>EnableAspectJAutoProxy</code>注解，将<code>proxyTargetClass</code>和<code>exposeProxy</code>属性注入到 <code>AnnotationAwareAspectJAutoProxyCreator</code>类的bean定义内。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将AnnotationAwareAspectJAutoProxyCreator注册到Bean容器</span></span><br><span class="line">AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(registry);</span><br><span class="line"></span><br><span class="line">AnnotationAttributes enableAspectJAutoProxy =</span><br><span class="line">    AnnotationConfigUtils.attributesFor(importingClassMetadata, EnableAspectJAutoProxy.class);</span><br><span class="line"><span class="keyword">if</span> (enableAspectJAutoProxy != <span class="keyword">null</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (enableAspectJAutoProxy.getBoolean(<span class="string">"proxyTargetClass"</span>)) &#123;</span><br><span class="line">    <span class="comment">// 注册属性proxyTargetClass</span></span><br><span class="line">    AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (enableAspectJAutoProxy.getBoolean(<span class="string">"exposeProxy"</span>)) &#123;</span><br><span class="line">    <span class="comment">// 注册属性exposeProxy</span></span><br><span class="line">    AopConfigUtils.forceAutoProxyCreatorToExposeProxy(registry);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p>
<h3 id="AOP代理对象的初始化构建"><a href="#AOP代理对象的初始化构建" class="headerlink" title="AOP代理对象的初始化构建"></a>AOP代理对象的初始化构建</h3><p>AOP的代理对象是在<code>BeanPostProcesser</code>的处理回调内创建的，AOP的代理创建类实现了<code>BeanPostProcesser</code>的接口，该类名为<code>AnnotationAwareAspectJAutoProxyCreator</code>。</p>
<p>本质上来说，是它的父类<code>AbstractAutoProxyCreator</code>实现了<code>SmartInstantiationAwareBeanPostProcessor</code>接口，而这个接口继承了<code>InstantiationAwareBeanPostProcessor</code>接口，同时<code>InstantiationAwareBeanPostProcessor</code>接口继承了<code>BeanPostProcesser</code>接口。</p>
<p>在类初始化完成后，会调用<code>AbstractAutoProxyCreator</code>类的<code>postProcessAfterInitialization</code>方法，在这个方法内，会获取目标对象的所有<code>advice</code>来判断是否需要构建代理类。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, <span class="keyword">null</span>);</span><br><span class="line"><span class="keyword">if</span> (specificInterceptors != DO_NOT_PROXY) &#123;</span><br><span class="line">  <span class="comment">// 需要代理，创建具体的代理类</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p>
<p>具体来看一下<code>getAdvicesAndAdvisorsForBean</code>方法，主要是搜索<code>Advisor</code>类的实现和标注有<code>@Aspect</code>注解的类，并且获取<code>@Aspect</code>注解类内的切面点（以下逻辑内容实现在<code>AnnotationAwareAspectJAutoProxyCreator</code>类内，覆盖了父类<code>AbstractAutoProxyCreator</code>的<code>findCandidateAdvisors</code>方法）。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Add all the Spring advisors found according to superclass rules.</span></span><br><span class="line">List&lt;Advisor&gt; advisors = <span class="keyword">super</span>.findCandidateAdvisors();</span><br><span class="line"><span class="comment">// Build Advisors for all AspectJ aspects in the bean factory.</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.aspectJAdvisorsBuilder != <span class="keyword">null</span>) &#123;</span><br><span class="line">  advisors.addAll(<span class="keyword">this</span>.aspectJAdvisorsBuilder.buildAspectJAdvisors());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> advisors;</span><br></pre></td></tr></table></figure><p></p>
<p>如果没有实现<code>Advisor</code>接口类，则super.findCandidateAdvisors()返回的会是一个空列表。本文也主要探究的是AspectJ相关的具体实现逻辑，所以忽略父类的<code>Advisor</code>搜索逻辑，来具体看一下<code>buildAspectJAdvisors</code>方法。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// this.aspectBeanNames缓存的是本次容器启动后的切面类名称列表，如果刚启动，则为空</span></span><br><span class="line">List&lt;String&gt; aspectNames = <span class="keyword">this</span>.aspectBeanNames;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否为null，如果是的话，锁类并且初始化切面类名称</span></span><br><span class="line"><span class="keyword">if</span> (aspectNames == <span class="keyword">null</span>) &#123;</span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">    <span class="comment">// 再次判断是否为空，确保其他线程在获取锁后不会重复做初始化操作</span></span><br><span class="line">    aspectNames = <span class="keyword">this</span>.aspectBeanNames;</span><br><span class="line">    <span class="keyword">if</span> (aspectNames == <span class="keyword">null</span>) &#123;</span><br><span class="line">      List&lt;Advisor&gt; advisors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">      aspectNames = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">      <span class="comment">// 查找所有父类为Object的bean对象</span></span><br><span class="line">      String[] beanNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(</span><br><span class="line">          <span class="keyword">this</span>.beanFactory, Object.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">      <span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">        <span class="comment">// 判断是否需要通过[includePatterns]属性过滤，不过Java配置的AOP貌似不支持这个属性，也可能是没找到在哪里</span></span><br><span class="line">        <span class="keyword">if</span> (!isEligibleBean(beanName)) &#123;</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 在这里不需要立即实例化类；因为，通过getType方法它会被Spring容器缓存，但是却不会被织入</span></span><br><span class="line">        Class&lt;?&gt; beanType = <span class="keyword">this</span>.beanFactory.getType(beanName);</span><br><span class="line">        <span class="keyword">if</span> (beanType == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断获取的类是否为Aspect类</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.advisorFactory.isAspect(beanType)) &#123;</span><br><span class="line">          <span class="comment">// 如果是的话，则将类加入切面类名称列表内</span></span><br><span class="line">          aspectNames.add(beanName);</span><br><span class="line">          <span class="comment">// 初始化切面元数据</span></span><br><span class="line">          AspectMetadata amd = <span class="keyword">new</span> AspectMetadata(beanType, beanName);</span><br><span class="line">          <span class="comment">// 判断切面类是否为单例类型</span></span><br><span class="line">          <span class="keyword">if</span> (amd.getAjType().getPerClause().getKind() == PerClauseKind.SINGLETON) &#123;</span><br><span class="line">            MetadataAwareAspectInstanceFactory factory =</span><br><span class="line">                <span class="keyword">new</span> BeanFactoryAspectInstanceFactory(<span class="keyword">this</span>.beanFactory, beanName);</span><br><span class="line">            <span class="comment">// 通过bean工厂类获取对应切面类的所有Advisor</span></span><br><span class="line">            List&lt;Advisor&gt; classAdvisors = <span class="keyword">this</span>.advisorFactory.getAdvisors(factory);</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.beanFactory.isSingleton(beanName)) &#123;</span><br><span class="line">              <span class="comment">// 如果bean工厂类为单例，则将Advisors缓存到key为切面类名的advisorsCache内</span></span><br><span class="line">              <span class="keyword">this</span>.advisorsCache.put(beanName, classAdvisors);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">// 如果bean工厂类不为实例，则缓存缓存到key为切面类名的aspectFactoryCache内</span></span><br><span class="line">              <span class="keyword">this</span>.aspectFactoryCache.put(beanName, factory);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将所有的Advisors缓存到advisors列表内</span></span><br><span class="line">            advisors.addAll(classAdvisors);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 每个切面类需要对应有工厂类</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.beanFactory.isSingleton(beanName)) &#123;</span><br><span class="line">              <span class="comment">// 如果工厂类是单例，则抛出异常</span></span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Bean with name '"</span> + beanName +</span><br><span class="line">                  <span class="string">"' is a singleton, but aspect instantiation model is not singleton"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 缓存缓存到key为切面类名的aspectFactoryCache内</span></span><br><span class="line">            MetadataAwareAspectInstanceFactory factory =</span><br><span class="line">                <span class="keyword">new</span> PrototypeAspectInstanceFactory(<span class="keyword">this</span>.beanFactory, beanName);</span><br><span class="line">            <span class="keyword">this</span>.aspectFactoryCache.put(beanName, factory);</span><br><span class="line">            advisors.addAll(<span class="keyword">this</span>.advisorFactory.getAdvisors(factory));</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">this</span>.aspectBeanNames = aspectNames;</span><br><span class="line">      <span class="keyword">return</span> advisors;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 切面类名称列表不为null</span></span><br><span class="line"><span class="comment">// 判断获取到的切面类名称列表是否为空</span></span><br><span class="line"><span class="keyword">if</span> (aspectNames.isEmpty()) &#123;</span><br><span class="line">  <span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">&#125;</span><br><span class="line">List&lt;Advisor&gt; advisors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (String aspectName : aspectNames) &#123;</span><br><span class="line">  <span class="comment">// 从advisorsCache内获取切面类的所有Advisors</span></span><br><span class="line">  List&lt;Advisor&gt; cachedAdvisors = <span class="keyword">this</span>.advisorsCache.get(aspectName);</span><br><span class="line">  <span class="keyword">if</span> (cachedAdvisors != <span class="keyword">null</span>) &#123;</span><br><span class="line">    advisors.addAll(cachedAdvisors);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果cachedAdvisors为空，则从aspectFactoryCache缓存内获取bean工厂，并且通过bean工厂获取所有的Advisors</span></span><br><span class="line">    MetadataAwareAspectInstanceFactory factory = <span class="keyword">this</span>.aspectFactoryCache.get(aspectName);</span><br><span class="line">    advisors.addAll(<span class="keyword">this</span>.advisorFactory.getAdvisors(factory));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> advisors;</span><br></pre></td></tr></table></figure><p></p>
<p>以上代码基本描述的就是遍历容器内的所有对象，并且判断对象是否是Aspect类型，如果是的话加入到Advisors列表内，并返回。具体判断逻辑如下：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断是否有@Aspect的注解或者这个类的字段名称存在`ajc$`前缀（如果被AspectJ Compiler编译的类会带有这个前缀）</span></span><br><span class="line"><span class="keyword">return</span> (hasAspectAnnotation(clazz) &amp;&amp; !compiledByAjc(clazz));</span><br></pre></td></tr></table></figure><p></p>
<p>获取了所有的Advisors之后，需要判断列表是否不为空，即<code>specificInterceptors != DO_NOT_PROXY</code>。</p>
<p>如果不为空，则创建具体的代理类。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将此advisor存入advisedBeans缓存</span></span><br><span class="line"><span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.TRUE);</span><br><span class="line"><span class="comment">// 创建代理对象</span></span><br><span class="line">Object proxy = createProxy(bean.getClass(), beanName, specificInterceptors, <span class="keyword">new</span> SingletonTargetSource(bean));</span><br><span class="line"><span class="comment">// 缓存代理类的类型，存入proxyTypes缓存</span></span><br><span class="line"><span class="keyword">this</span>.proxyTypes.put(cacheKey, proxy.getClass());</span><br><span class="line"><span class="keyword">return</span> proxy;</span><br></pre></td></tr></table></figure><p></p>
<p>先看下代理类的具体创建逻辑：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">createProxy</span><span class="params">(Class&lt;?&gt; beanClass, @Nullable String beanName,</span></span></span><br><span class="line"><span class="function"><span class="params">			@Nullable Object[] specificInterceptors, TargetSource targetSource)</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 如果bean工厂是ConfigurableListableBeanFactory的实例，则标记exposeTargetClass属性</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.beanFactory <span class="keyword">instanceof</span> ConfigurableListableBeanFactory) &#123;</span><br><span class="line">    AutoProxyUtils.exposeTargetClass((ConfigurableListableBeanFactory) <span class="keyword">this</span>.beanFactory, beanName, beanClass);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ProxyFactory proxyFactory = <span class="keyword">new</span> ProxyFactory();</span><br><span class="line">  proxyFactory.copyFrom(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断AspectJ有没有设置proxyTargetClass属性（代理类直接继承目标类）</span></span><br><span class="line">  <span class="keyword">if</span> (!proxyFactory.isProxyTargetClass()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (shouldProxyTargetClass(beanClass, beanName)) &#123;</span><br><span class="line">      proxyFactory.setProxyTargetClass(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      evaluateProxyInterfaces(beanClass, proxyFactory);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 构建切面</span></span><br><span class="line">  <span class="comment">// 对所有的切面（common、advisor、advice）做一次封装，将之全部分装为Advisor类型</span></span><br><span class="line">  Advisor[] advisors = buildAdvisors(beanName, specificInterceptors);</span><br><span class="line">  proxyFactory.addAdvisors(advisors);</span><br><span class="line">  <span class="comment">// 设置代理目标类</span></span><br><span class="line">  proxyFactory.setTargetSource(targetSource);</span><br><span class="line">  <span class="comment">// 子类回调，目前AnnotationAwareAspectJAutoProxyCreator未覆盖该方法，忽略</span></span><br><span class="line">  customizeProxyFactory(proxyFactory);</span><br><span class="line"></span><br><span class="line">  proxyFactory.setFrozen(<span class="keyword">this</span>.freezeProxy);</span><br><span class="line">  <span class="keyword">if</span> (advisorsPreFiltered()) &#123;</span><br><span class="line">    proxyFactory.setPreFiltered(<span class="keyword">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取代理类</span></span><br><span class="line">  <span class="keyword">return</span> proxyFactory.getProxy(getProxyClassLoader());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p>
<p>接下来就是通过代理工厂来具体创建代理类，Spring中，可以通过两种方式来创建代理类：</p>
<ul>
<li>Jdk动态代理</li>
<li>Cglib动态代理</li>
</ul>
<p>具体使用哪种方式的通过如下条件判断：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 未配置优化且未设置proxyTargetClass为true且有用户自定义的代理接口，则直接使用JDK动态代理</span></span><br><span class="line"><span class="keyword">if</span> (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) &#123;</span><br><span class="line">  Class&lt;?&gt; targetClass = config.getTargetClass();</span><br><span class="line">  <span class="keyword">if</span> (targetClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">"TargetSource cannot determine target class: "</span> +</span><br><span class="line">        <span class="string">"Either an interface or a target is required for proxy creation."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 目标代理类为接口或者是代理类，则使用JDK动态代理</span></span><br><span class="line">  <span class="keyword">if</span> (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 其他情况使用Cglib动态代理</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> ObjenesisCglibAopProxy(config);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p>
<p>在这里，对JDK动态代理不做具体分析，具体来看<code>ObjenesisCglibAopProxy</code>类内<code>getProxy</code>的获取：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">  logger.debug(<span class="string">"Creating CGLIB proxy: target source is "</span> + <span class="keyword">this</span>.advised.getTargetSource());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  Class&lt;?&gt; rootClass = <span class="keyword">this</span>.advised.getTargetClass();</span><br><span class="line">  Assert.state(rootClass != <span class="keyword">null</span>, <span class="string">"Target class must be available for creating a CGLIB proxy"</span>);</span><br><span class="line"></span><br><span class="line">  Class&lt;?&gt; proxySuperClass = rootClass;</span><br><span class="line">  <span class="keyword">if</span> (ClassUtils.isCglibProxyClass(rootClass)) &#123;</span><br><span class="line">    proxySuperClass = rootClass.getSuperclass();</span><br><span class="line">    Class&lt;?&gt;[] additionalInterfaces = rootClass.getInterfaces();</span><br><span class="line">    <span class="keyword">for</span> (Class&lt;?&gt; additionalInterface : additionalInterfaces) &#123;</span><br><span class="line">      <span class="keyword">this</span>.advised.addInterface(additionalInterface);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Validate the class, writing log messages as necessary.</span></span><br><span class="line">  validateClassIfNecessary(proxySuperClass, classLoader);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Configure CGLIB Enhancer...</span></span><br><span class="line">  Enhancer enhancer = createEnhancer();</span><br><span class="line">  <span class="keyword">if</span> (classLoader != <span class="keyword">null</span>) &#123;</span><br><span class="line">    enhancer.setClassLoader(classLoader);</span><br><span class="line">    <span class="keyword">if</span> (classLoader <span class="keyword">instanceof</span> SmartClassLoader &amp;&amp;</span><br><span class="line">        ((SmartClassLoader) classLoader).isClassReloadable(proxySuperClass)) &#123;</span><br><span class="line">      enhancer.setUseCache(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  enhancer.setSuperclass(proxySuperClass);</span><br><span class="line">  enhancer.setInterfaces(AopProxyUtils.completeProxiedInterfaces(<span class="keyword">this</span>.advised));</span><br><span class="line">  enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE);</span><br><span class="line">  enhancer.setStrategy(<span class="keyword">new</span> ClassLoaderAwareUndeclaredThrowableStrategy(classLoader));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取回调方法（其中包括最重要的aopInterceptor，用于advices调用链的处理）</span></span><br><span class="line">  Callback[] callbacks = getCallbacks(rootClass);</span><br><span class="line">  Class&lt;?&gt;[] types = <span class="keyword">new</span> Class&lt;?&gt;[callbacks.length];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; types.length; x++) &#123;</span><br><span class="line">    types[x] = callbacks[x].getClass();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// fixedInterceptorMap only populated at this point, after getCallbacks call above</span></span><br><span class="line">  enhancer.setCallbackFilter(<span class="keyword">new</span> ProxyCallbackFilter(</span><br><span class="line">      <span class="keyword">this</span>.advised.getConfigurationOnlyCopy(), <span class="keyword">this</span>.fixedInterceptorMap, <span class="keyword">this</span>.fixedInterceptorOffset));</span><br><span class="line">  enhancer.setCallbackTypes(types);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 生成代理class和代理实例</span></span><br><span class="line">  <span class="keyword">return</span> createProxyClassAndInstance(enhancer, callbacks);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (CodeGenerationException | IllegalArgumentException ex) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">"Could not generate CGLIB subclass of "</span> + <span class="keyword">this</span>.advised.getTargetClass() +</span><br><span class="line">      <span class="string">": Common causes of this problem include using a final class or a non-visible class"</span>,</span><br><span class="line">      ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">  <span class="comment">// TargetSource.getTarget() failed</span></span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">"Unexpected AOP exception"</span>, ex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p>
<h3 id="AOP-advice的顺序问题"><a href="#AOP-advice的顺序问题" class="headerlink" title="AOP advice的顺序问题"></a>AOP advice的顺序问题</h3><p>其实在通过<code>AbstractAutoProxyCreator</code>类的<code>findCandidateAdvisors</code>方法获取所有的advice后，会对这些advice做一个排序处理：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!eligibleAdvisors.isEmpty()) &#123;</span><br><span class="line">  eligibleAdvisors = sortAdvisors(eligibleAdvisors);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p>
<p>Advisors的排序实现是通过<code>AnnotationAwareOrderComparator</code>类来达成的。这个类继承了<code>OrderComparator</code>类，覆盖了<code>findOrder</code>和<code>getPriority</code>方法。</p>
<p>其内部实现的顺序为：Ordered接口 -&gt; 类级别的Order -&gt; 类级别的Prority -&gt; 其他被注解元素的Order -&gt; 其他被注解元素的Prority。</p>
<h3 id="AOP-advice的具体调用"><a href="#AOP-advice的具体调用" class="headerlink" title="AOP advice的具体调用"></a>AOP advice的具体调用</h3><p>Spring AOP的实现并不是将所有的advice硬编码进目标代理类，而是通过织入<code>DynamicAdvisedInterceptor</code>类，在<code>intercept</code>方法内部调用advice调用链来达到拦截的目的。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object proxy, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">  Object oldProxy = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">boolean</span> setProxyContext = <span class="keyword">false</span>;</span><br><span class="line">  Object target = <span class="keyword">null</span>;</span><br><span class="line">  TargetSource targetSource = <span class="keyword">this</span>.advised.getTargetSource();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.advised.exposeProxy) &#123;</span><br><span class="line">      <span class="comment">// Make invocation available if necessary.</span></span><br><span class="line">      oldProxy = AopContext.setCurrentProxy(proxy);</span><br><span class="line">      setProxyContext = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Get as late as possible to minimize the time we "own" the target, in case it comes from a pool...</span></span><br><span class="line">    target = targetSource.getTarget();</span><br><span class="line">    Class&lt;?&gt; targetClass = (target != <span class="keyword">null</span> ? target.getClass() : <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// 通过拦截的方法和目标对象，获取该方法的拦截调用链</span></span><br><span class="line">    List&lt;Object&gt; chain = <span class="keyword">this</span>.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);</span><br><span class="line">    Object retVal;</span><br><span class="line">    <span class="comment">// Check whether we only have one InvokerInterceptor: that is,</span></span><br><span class="line">    <span class="comment">// no real advice, but just reflective invocation of the target.</span></span><br><span class="line">    <span class="keyword">if</span> (chain.isEmpty() &amp;&amp; Modifier.isPublic(method.getModifiers())) &#123;</span><br><span class="line">      <span class="comment">// We can skip creating a MethodInvocation: just invoke the target directly.</span></span><br><span class="line">      <span class="comment">// Note that the final invoker must be an InvokerInterceptor, so we know</span></span><br><span class="line">      <span class="comment">// it does nothing but a reflective operation on the target, and no hot</span></span><br><span class="line">      <span class="comment">// swapping or fancy proxying.</span></span><br><span class="line">      Object[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args);</span><br><span class="line">      retVal = methodProxy.invoke(target, argsToUse);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// We need to create a method invocation...</span></span><br><span class="line">      <span class="comment">// 如果存在调用链，则实例化一个CglibMethodInvocation类，并执行获得返回值</span></span><br><span class="line">      retVal = <span class="keyword">new</span> CglibMethodInvocation(proxy, target, method, args, targetClass, chain, methodProxy).proceed();</span><br><span class="line">    &#125;</span><br><span class="line">    retVal = processReturnType(proxy, target, method, retVal);</span><br><span class="line">    <span class="keyword">return</span> retVal;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (target != <span class="keyword">null</span> &amp;&amp; !targetSource.isStatic()) &#123;</span><br><span class="line">      targetSource.releaseTarget(target);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (setProxyContext) &#123;</span><br><span class="line">      <span class="comment">// Restore old proxy.</span></span><br><span class="line">      AopContext.setCurrentProxy(oldProxy);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p>
<p>接下来看下<code>CglibMethodInvocation</code>的<code>proceed</code>方法：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//	We start with an index of -1 and increment early.</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.currentInterceptorIndex == <span class="keyword">this</span>.interceptorsAndDynamicMethodMatchers.size() - <span class="number">1</span>) &#123;</span><br><span class="line">  <span class="comment">// 如果调用链全部执行完毕，则执行被代理对象的原方法</span></span><br><span class="line">  <span class="keyword">return</span> invokeJoinpoint();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获得本次的advice</span></span><br><span class="line">Object interceptorOrInterceptionAdvice =</span><br><span class="line">    <span class="keyword">this</span>.interceptorsAndDynamicMethodMatchers.get(++<span class="keyword">this</span>.currentInterceptorIndex);</span><br><span class="line"><span class="keyword">if</span> (interceptorOrInterceptionAdvice <span class="keyword">instanceof</span> InterceptorAndDynamicMethodMatcher) &#123;</span><br><span class="line">  <span class="comment">// Evaluate dynamic method matcher here: static part will already have</span></span><br><span class="line">  <span class="comment">// been evaluated and found to match.</span></span><br><span class="line">  InterceptorAndDynamicMethodMatcher dm =</span><br><span class="line">      (InterceptorAndDynamicMethodMatcher) interceptorOrInterceptionAdvice;</span><br><span class="line">  <span class="keyword">if</span> (dm.methodMatcher.matches(<span class="keyword">this</span>.method, <span class="keyword">this</span>.targetClass, <span class="keyword">this</span>.arguments)) &#123;</span><br><span class="line">    <span class="keyword">return</span> dm.interceptor.invoke(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Dynamic matching failed.</span></span><br><span class="line">    <span class="comment">// Skip this interceptor and invoke the next in the chain.</span></span><br><span class="line">    <span class="keyword">return</span> proceed();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// It's an interceptor, so we just invoke it: The pointcut will have</span></span><br><span class="line">  <span class="comment">// been evaluated statically before this object was constructed.</span></span><br><span class="line">  <span class="comment">// 继续执行下一个拦截器</span></span><br><span class="line">  <span class="keyword">return</span> ((MethodInterceptor) interceptorOrInterceptionAdvice).invoke(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p>
<p>拦截器的执行顺序，是根据调用链的顺序来执行的，而调用链的顺序早在之前的sort阶段就已经排列好了；如下的代码主要是获取目标对象和方法对应的拦截器链：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Object&gt; <span class="title">getInterceptorsAndDynamicInterceptionAdvice</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">			Advised config, Method method, @Nullable Class&lt;?&gt; targetClass)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// This is somewhat tricky... We have to process introductions first,</span></span><br><span class="line">  <span class="comment">// but we need to preserve order in the ultimate list.</span></span><br><span class="line">  List&lt;Object&gt; interceptorList = <span class="keyword">new</span> ArrayList&lt;Object&gt;(config.getAdvisors().length);</span><br><span class="line">  Class&lt;?&gt; actualClass = (targetClass != <span class="keyword">null</span> ? targetClass : method.getDeclaringClass());</span><br><span class="line">  <span class="keyword">boolean</span> hasIntroductions = hasMatchingIntroductions(config, actualClass);</span><br><span class="line">  AdvisorAdapterRegistry registry = GlobalAdvisorAdapterRegistry.getInstance();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (Advisor advisor : config.getAdvisors()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (advisor <span class="keyword">instanceof</span> PointcutAdvisor) &#123;</span><br><span class="line">      <span class="comment">// Add it conditionally.</span></span><br><span class="line">      PointcutAdvisor pointcutAdvisor = (PointcutAdvisor) advisor;</span><br><span class="line">      <span class="keyword">if</span> (config.isPreFiltered() || pointcutAdvisor.getPointcut().getClassFilter().matches(actualClass)) &#123;</span><br><span class="line">        MethodMatcher mm = pointcutAdvisor.getPointcut().getMethodMatcher();</span><br><span class="line">        <span class="keyword">if</span> (MethodMatchers.matches(mm, method, actualClass, hasIntroductions)) &#123;</span><br><span class="line">          MethodInterceptor[] interceptors = registry.getInterceptors(advisor);</span><br><span class="line">          <span class="keyword">if</span> (mm.isRuntime()) &#123;</span><br><span class="line">            <span class="comment">// Creating a new object instance in the getInterceptors() method</span></span><br><span class="line">            <span class="comment">// isn't a problem as we normally cache created chains.</span></span><br><span class="line">            <span class="keyword">for</span> (MethodInterceptor interceptor : interceptors) &#123;</span><br><span class="line">              interceptorList.add(<span class="keyword">new</span> InterceptorAndDynamicMethodMatcher(interceptor, mm));</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span> &#123;</span><br><span class="line">            interceptorList.addAll(Arrays.asList(interceptors));</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (advisor <span class="keyword">instanceof</span> IntroductionAdvisor) &#123;</span><br><span class="line">      IntroductionAdvisor ia = (IntroductionAdvisor) advisor;</span><br><span class="line">      <span class="keyword">if</span> (config.isPreFiltered() || ia.getClassFilter().matches(actualClass)) &#123;</span><br><span class="line">        Interceptor[] interceptors = registry.getInterceptors(advisor);</span><br><span class="line">        interceptorList.addAll(Arrays.asList(interceptors));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      Interceptor[] interceptors = registry.getInterceptors(advisor);</span><br><span class="line">      interceptorList.addAll(Arrays.asList(interceptors));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> interceptorList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p>
<p>举个例子，声明拦截目标类：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">world</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello world"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p>
<p>定义两个拦截器HelloAop以及HelloAop2：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloAop</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"execution(* com.whatakitty.learn.Hello.*(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">world</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"world()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"start hello world"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After</span>(<span class="string">"world()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"end hello world"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around</span>(<span class="string">"world()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">around</span><span class="params">(ProceedingJoinPoint proceedingJoinPoint)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"around 1"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            proceedingJoinPoint.proceed();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">            throwable.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"around 1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloAop2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"execution(* com.whatakitty.learn.Hello.*(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">world</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"world()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"start hello world 2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After</span>(<span class="string">"world()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"end hello world 2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around</span>(<span class="string">"world()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">around</span><span class="params">(ProceedingJoinPoint proceedingJoinPoint)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"around 2"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            proceedingJoinPoint.proceed();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">            throwable.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"around 2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果如下：<br></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">around 1</span><br><span class="line">start hello world</span><br><span class="line">around 2</span><br><span class="line">start hello world 2</span><br><span class="line">hello world</span><br><span class="line">around 2</span><br><span class="line">end hello world 2</span><br><span class="line">around 1</span><br><span class="line">end hello world</span><br></pre></td></tr></table></figure><p></p>
      
    </div>

  </div>

  
  <div class="article-copyright">
      <div class="copyright"><p><span>本文标题:</span><a href="/多个AspectJ对同一个对象操作产生的实际效果以及顺序情况.html">多个AspectJ对同一个对象操作产生的实际效果以及顺序情况</a></p><p><span>文章作者:</span><a href="/" title="访问 WhatAKitty 的个人博客">WhatAKitty</a></p><p><span>发布时间:</span>2018年08月20日 - 23时11分</p><p><span>最后更新:</span>2018年08月20日 - 23时14分</p><p><span>原始链接:</span><a href="/多个AspectJ对同一个对象操作产生的实际效果以及顺序情况.html" title="多个AspectJ对同一个对象操作产生的实际效果以及顺序情况">https://xuqiang.me/多个AspectJ对同一个对象操作产生的实际效果以及顺序情况.html</a> <span class="btn" data-clipboard-text="原文: https://xuqiang.me/多个AspectJ对同一个对象操作产生的实际效果以及顺序情况.html　　作者: WhatAKitty" title="点击复制文章链接"><i class="fa fa-clipboard"></i></span></p><p><span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/3.0/cn/" title="中国大陆 (CC BY-NC-SA 3.0 CN)">"署名-非商用-相同方式共享 3.0"</a> 转载请保留原文链接及作者。</p></div><br><br><style type="text/css">.copyright p .btn{margin-left:1em}.copyright:hover p .btn::after{content:"复制"}.copyright p .btn:hover{color:gray;cursor:pointer}</style>
  </div>
  

  

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/Java/">Java</a>, <a href="/categories/Java/Spring/">Spring</a>, <a href="/categories/Java/Spring/SpringSources/">SpringSources</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/java/">java</a><a href="/tags/spring/">spring</a><a href="/tags/aspectj/">aspectj</a><a href="/tags/cglib/">cglib</a><a href="/tags/aop/">aop</a>
    </span>
    

    </div>

    
    <div class="article-meta pull-right">
      <span style="display:inline-block;width:83px">
        <a style="float:left;text-decoration:none" target="_blank" href="https://www.banquanyin.com/u/101709260007755">
          <img src="https://s1.banquanyin.com/c/icon-yin-24.png" title="更多授权" style="width:inherit">
        </a>
        <a target="_blank" href="https://101709260007755.bqy.mobi">
          <img src="https://s1.banquanyin.com/c/icon-auth-cr-24.png" title="获取授权" style="width:inherit">
        </a>
      </span>
    </div>
    

    
  </div>

  
    <div style="text-align:center;margin-top:80px">
      <div id="cyReward" role="cylabs" data-use="reward" sid="b4d175fc09200d07800dcdddb04ab421" cid="1"></div>
    </div>
  

</article>


  <div id="SOHUCS" sid="b4d175fc09200d07800dcdddb04ab421"></div><script type="text/javascript">!function(){var t="1243e90ae1a56c027241ecf5b99daeda";(window.innerWidth||document.documentElement.clientWidth)<960?window.document.write('<script id="changyan_mobile_js" charset="utf-8" type="text/javascript" src="https://changyan.sohu.com/upload/mobile/wap-js/changyan_mobile.js?client_id=cytdcyLLd&conf='+t+'"><\/script>'):function(t,e){var n=document.getElementsByTagName("head")[0]||document.head||document.documentElement,a=document.createElement("script");a.setAttribute("type","text/javascript"),a.setAttribute("charset","UTF-8"),a.setAttribute("src","https://changyan.sohu.com/upload/changyan.js"),"function"==typeof e&&(window.attachEvent?a.onreadystatechange=function(){var t=a.readyState;"loaded"!==t&&"complete"!==t||(a.onreadystatechange=null,e())}:a.onload=e),n.appendChild(a)}(0,function(){window.changyan.api.config({appid:"cytdcyLLd",conf:t})})}()</script><script type="text/javascript" charset="utf-8" src="https://changyan.itc.cn/js/lib/jquery.js"></script><script type="text/javascript" charset="utf-8" src="https://changyan.sohu.com/js/changyan.labs.https.js?appid=cytdcyLLd"></script>
    </main>

    <footer class="site-footer"><p class="site-info">Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a><br>&copy; 2018 WhatAKitty<br><a href="https://blog.whatakitty.com">浙ICP备15019585号</a> <a target="_blank" href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=33010602008839" style="display:block;line-height:20px"><span style="display:inline-block;line-height:20px;vertical-align:middle"><img src="https://static.xuqiang.me/public/images/beian.png" style="width:20px;height:20px"></span><span style="display:inline-block;height:20px;line-height:20px;margin:0 0 0 5px">浙公网安备 33010602008839号</span></a></p></footer>
    
    <script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?1d4c4cd810512d2fddb7187b7939389a";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script></div></div></body></html>
