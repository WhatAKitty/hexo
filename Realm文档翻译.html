<!DOCTYPE HTML><html><head><meta charset="utf-8"><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>【翻译】Realm Javascript 1.12.0文档 | WhatAKitty Daily | A Programmer&#39;s Daily Record</title><meta name="author" content="WhatAKitty"><meta name="description" content="Just A Simple Programmer."><meta name="keywords" content="翻译,中文,文档,realm,react-native,react native,javascript,es6,es5,node,nodejs,react,1.12.0,latest,Blog, SSL, Nodejs, DevOps, Spring, Spring Cloud, Jenkins, Docker, JIRA, CI"><meta id="viewport" name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1,user-scalable=no,minimal-ui"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta property="og:title" content="【翻译】Realm Javascript 1.12.0文档"><meta property="og:site_name" content="WhatAKitty Daily"><meta property="og:image" content="/favicon.ico"><link href="/favicon.ico" rel="icon"><link rel="alternate" href="/atom.xml" title="WhatAKitty Daily" type="application/atom+xml"><link rel="stylesheet" href="/css/style.css" media="screen" type="text/css"></head><body><div class="blog"><div class="content"><header><div class="site-branding"><h1 class="site-title"><a href="/">WhatAKitty Daily</a></h1><p class="site-description">A Programmer&#39;s Daily Record</p></div><nav class="site-navigation"><ul><li><a href="/">主页</a></li><li><a href="/archives">归档</a></li><li><a href="/projects">项目</a></li><li><a href="/categories/JavaSources">Java Sources</a></li><li><a href="/atom.xml">订阅</a></li></ul></nav></header><main class="site-main posts-loop"><article><h3 class="article-title"><span>【翻译】Realm Javascript 1.12.0文档</span></h3><div class="article-top-meta"><span class="posted-on"><a href="/Realm文档翻译.html" rel="bookmark">WhatAKitty &emsp; <time class="entry-date published" datetime="2017-10-14T04:12:12.000Z">2017-10-14</time></a></span></div><div class="article-content"><div class="entry"><ul><li>2017-10-14 创建</li><li>2017-10-15 更新</li><li>2017-10-16 更新</li></ul><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>Realm Javascript版本能够帮助你安全、持续、快速有效的构建你的model层。Realm Javascript被设计用于React Native和Nodejs应用。</p><p>这里有个快速简单的例子：</p><a id="more"></a><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Realm = <span class="built_in">require</span>(<span class="string">'realm'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义你的model和它的属性</span></span><br><span class="line"><span class="keyword">const</span> CarSchema = &#123;</span><br><span class="line">  name: <span class="string">'Car'</span>,</span><br><span class="line">  properties: &#123;</span><br><span class="line">    make:  <span class="string">'string'</span>,</span><br><span class="line">    model: <span class="string">'string'</span>,</span><br><span class="line">    miles: &#123;<span class="attr">type</span>: <span class="string">'int'</span>, <span class="attr">default</span>: <span class="number">0</span>&#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> PersonSchema = &#123;</span><br><span class="line">  name: <span class="string">'Person'</span>,</span><br><span class="line">  properties: &#123;</span><br><span class="line">    name:     <span class="string">'string'</span>,</span><br><span class="line">    birthday: <span class="string">'date'</span>,</span><br><span class="line">    cars:     &#123;<span class="attr">type</span>: <span class="string">'list'</span>, <span class="attr">objectType</span>: <span class="string">'Car'</span>&#125;,</span><br><span class="line">    picture:  &#123;<span class="attr">type</span>: <span class="string">'data'</span>, <span class="attr">optional</span>: <span class="literal">true</span>&#125;, <span class="comment">// 可选属性</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Realm.open(&#123;<span class="attr">schema</span>: [CarSchema, PersonSchema]&#125;)</span><br><span class="line">  .then(<span class="function"><span class="params">realm</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 创建Realm对象，并且存储到local storage中</span></span><br><span class="line">    realm.write(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> myCar = realm.create(<span class="string">'Car'</span>, &#123;</span><br><span class="line">        make: <span class="string">'Honda'</span>,</span><br><span class="line">        model: <span class="string">'Civic'</span>,</span><br><span class="line">        miles: <span class="number">1000</span>,</span><br><span class="line">      &#125;);</span><br><span class="line">      myCar.miles += <span class="number">20</span>; <span class="comment">// 更新一个属性值</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Query Realm for all cars with a high mileage</span></span><br><span class="line">    <span class="keyword">const</span> cars = realm.objects(<span class="string">'Car'</span>).filtered(<span class="string">'miles &gt; 1000'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将会带着一个我们之前创建的car返回一个结果对象</span></span><br><span class="line">    cars.length <span class="comment">// =&gt; 1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add another car</span></span><br><span class="line">    realm.write(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> myCar = realm.create(<span class="string">'Car'</span>, &#123;</span><br><span class="line">        make: <span class="string">'Ford'</span>,</span><br><span class="line">        model: <span class="string">'Focus'</span>,</span><br><span class="line">        miles: <span class="number">2000</span>,</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询结果是实时更新的</span></span><br><span class="line">    cars.length <span class="comment">// =&gt; 2</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
<p>请注意，如果你将要在server-side/node使用Realm，可以通过<a href="https://realm.io/docs/realm-object-server/" target="_blank" rel="noopener">Realm对象服务</a>查看一些额外信息。</p>
<h1 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>跟着以下步骤通过npm来安装Realm Javascript，或者在<a href="https://github.com/realm/realm-js" target="_blank" rel="noopener">Github</a>查看源码</p>
<h3 id="React-Native"><a href="#React-Native" class="headerlink" title="React Native"></a>React Native</h3><h4 id="先决条件"><a href="#先决条件" class="headerlink" title="先决条件"></a>先决条件</h4><ul>
<li><p>确保你已经准备好React Native运行环境，按照<a href="https://facebook.github.io/react-native/docs/getting-started.html" target="_blank" rel="noopener">React Native指引</a>来开始；</p>
</li>
<li><p>使用了Realm的应用程序需要可以在IOS和Android平台运行；</p>
</li>
<li><p>React Native 版本必须大于等于 0.31.0</p>
</li>
</ul>
<h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><ul>
<li><p>创建一个React Native项目：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">react-native init &lt;project-name&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>进入新创建的项目内并且添加realm依赖：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span># npm 安装</span><br><span class="line">npm install --save realm</span><br><span class="line"><span class="meta">#</span># yarn 安装</span><br><span class="line">yarn add realm</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>接下来，将你的项目链接到Realm的本地模板：<br></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">react-native link realm</span><br></pre></td></tr></table></figure><p></p>
<p><em>Android警告</em>：由于版本关系，<code>react-native link</code>可能会生成一个无效的配置，能够正确更新Gradle（<code>android/settings.gradle</code>和<code>android/app/build.gradle</code>）但是添加Realm模块失败。请确认<code>react-native link</code>正确的添加了Realm模块；如果没有的话，按照下列步骤手动添加到库：</p>
<ol>
<li><p>添加下列的代码到<code>android/settings.gradle</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">include &apos;:realm&apos;</span><br><span class="line">project(&apos;:realm&apos;).projectDir = new File(rootProject.projectDir, &apos;../node_modules/realm/android&apos;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>在<code>android/app/build.gradle</code>文件中，将Realm库编译行添加到依赖：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    compile project(&apos;:realm&apos;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在<code>MainApplication.java</code>中添加引用并且连接包：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.realm.react.RealmReactPackage; <span class="comment">// 增加这个引入</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainApplication</span> <span class="keyword">extends</span> <span class="title">Application</span> <span class="keyword">implements</span> <span class="title">ReactApplication</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> List&lt;ReactPackage&gt; <span class="title">getPackages</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Arrays.&lt;ReactPackage&gt;asList(</span><br><span class="line">            <span class="keyword">new</span> MainReactPackage(),</span><br><span class="line">            <span class="keyword">new</span> RealmReactPackage() <span class="comment">// 增加这一行</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>你现在已经准备完毕。想要实践下Realm，在<code>index.ios.js</code>和<code>index.android.js</code>内将<code>class &lt;project-name&gt;</code>类定义替换成以下代码：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">const Realm = require(&apos;realm&apos;);</span><br><span class="line"></span><br><span class="line">class &lt;project-name&gt; extends Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state = &#123; realm: null &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentWillMount() &#123;</span><br><span class="line">    Realm.open(&#123;</span><br><span class="line">      schema: [&#123;name: &apos;Dog&apos;, properties: &#123;name: &apos;string&apos;&#125;&#125;]</span><br><span class="line">    &#125;).then(realm =&gt; &#123;</span><br><span class="line">      realm.write(() =&gt; &#123;</span><br><span class="line">        realm.create(&apos;Dog&apos;, &#123;name: &apos;Rex&apos;&#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">      this.setState(&#123; realm &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    const info = this.state.realm</span><br><span class="line">      ? &apos;Number of dogs in this Realm: &apos; + this.state.realm.objects(&apos;Dog&apos;).length</span><br><span class="line">      : &apos;Loading...&apos;;</span><br><span class="line"></span><br><span class="line">    return (</span><br><span class="line">      &lt;View style=&#123;styles.container&#125;&gt;</span><br><span class="line">        &lt;Text style=&#123;styles.welcome&#125;&gt;</span><br><span class="line">          &#123;info&#125;</span><br><span class="line">        &lt;/Text&gt;</span><br><span class="line">      &lt;/View&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p>
<p>你可以在设备或者模拟器上运行你的代码。</p>
<h3 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h3><p>这些只是指导安装Realm Node.js SDK开发者版本。如果你已经下载了专业版或者企业版，按照你收到邮件的安装指导进行。</p>
<p>简单的使用npm包管理器来安装realm：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save realm</span><br></pre></td></tr></table></figure><p></p>
<p>想要使用SDK，在你的项目中<code>require(&#39;realm&#39;)</code>。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var Realm = require(&apos;realm&apos;);</span><br></pre></td></tr></table></figure><p></p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><p>可以在Github的<a href="https://github.com/realm/realm-js/tree/master/examples" target="_blank" rel="noopener">realm-js库</a>中找到。</p>
<p>在Android中要注意，你需要安装有NDK并且设置了ANDROID_NDK的环境变量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export ANDROID_NDK=/usr/local/Cellar/android-ndk/r10e</span><br></pre></td></tr></table></figure>
<h1 id="获取帮助"><a href="#获取帮助" class="headerlink" title="获取帮助"></a>获取帮助</h1><ul>
<li><p>由于你的代码需要帮助？<a href="http://stackoverflow.com/questions/ask?tags=realm" target="_blank" rel="noopener">在Stackoverflow上提问</a>，我们在Stackoverflow上很活跃的查看和回答问题！</p>
</li>
<li><p>有bug需要报告？<a href="https://github.com/realm/realm-js/issues/new" target="_blank" rel="noopener">在我们的代码库上提ISSUE</a>。如果可能的话，附带上Realm的版本，一个完整的日志，realm文件和ISSUE上提问相关的项目代码。</p>
</li>
<li><p>有新功能要求？<a href="https://github.com/realm/realm-js/issues/new" target="_blank" rel="noopener">在我们的代码库上提ISSUE</a>。告诉我们这个功能实现什么，为什么需要这个功能。</p>
</li>
</ul>
<h1 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h1><p>Realm 数据 models 通过 schema 信息定义，在Realm初始化期间将定义传入。<br>一个对象的schema定义包含了对象的名称和一系列的属性，每个属性都有它自己的名字和类型；同时也可以将属性定义为一个object或者list，引用其他对象类型。你也可以指定每个属性是否可选或者是否有个默认值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Realm = <span class="built_in">require</span>(<span class="string">'realm'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> CarSchema = &#123;</span><br><span class="line">  name: <span class="string">'Car'</span>,</span><br><span class="line">  properties: &#123;</span><br><span class="line">    make:  <span class="string">'string'</span>,</span><br><span class="line">    model: <span class="string">'string'</span>,</span><br><span class="line">    miles: &#123;<span class="attr">type</span>: <span class="string">'int'</span>, <span class="attr">default</span>: <span class="number">0</span>&#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> PersonSchema = &#123;</span><br><span class="line">  name: <span class="string">'Person'</span>,</span><br><span class="line">  properties: &#123;</span><br><span class="line">    name:     <span class="string">'string'</span>,</span><br><span class="line">    birthday: <span class="string">'date'</span>,</span><br><span class="line">    cars:     &#123;<span class="attr">type</span>: <span class="string">'list'</span>, <span class="attr">objectType</span>: <span class="string">'Car'</span>&#125;,</span><br><span class="line">    picture:  &#123;<span class="attr">type</span>: <span class="string">'data'</span>, <span class="attr">optional</span>: <span class="literal">true</span>&#125;, <span class="comment">// 可选属性</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 附带Car和Person models初始化Realm</span></span><br><span class="line">Realm.open(&#123;<span class="attr">schema</span>: [CarSchema, PersonSchema]&#125;)</span><br><span class="line">  .then(<span class="function"><span class="params">realm</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// ... 使用realm实例来读取或者修改数据</span></span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>
<h2 id="Classes"><a href="#Classes" class="headerlink" title="Classes"></a>Classes</h2><p>在这点上，通过类定义模型的支持是有限的。它能够在React Native上生效，但是在Node中不起作用。</p>
<p>如果你想要使用ES2015样式的类（也有可能需要继承存在的一些特性），你只需要在构造器中定义schema就可以了：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  get fullName() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.firstName + <span class="string">' '</span> + <span class="keyword">this</span>.lastName;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.schema = &#123;</span><br><span class="line">  name: <span class="string">'Person'</span>,</span><br><span class="line">  properties: &#123;</span><br><span class="line">    firstName: &#123;<span class="attr">type</span>: <span class="string">'string'</span>&#125;,</span><br><span class="line">    lastName: &#123;<span class="attr">type</span>: <span class="string">'string'</span>&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p></p>
<p>你现在就可以将类本身传递到<code>open</code>配置中的<code>schema</code>属性内：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Realm.open(&#123;<span class="attr">schema</span>: [Person]&#125;)</span><br><span class="line">  .then( <span class="comment">/* ... */</span> );</span><br></pre></td></tr></table></figure><p></p>
<p>你可以一直使用以下方法访问属性：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">realm.write(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> john = realm.create(<span class="string">'Person'</span>, &#123;</span><br><span class="line">    firstName: <span class="string">'John'</span>,</span><br><span class="line">    lastName: <span class="string">'Smith'</span></span><br><span class="line">  &#125;);</span><br><span class="line">  john.lastName = <span class="string">'Peterson'</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(john.fullName); <span class="comment">// -&gt; 'John Peterson'</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p></p>
<h2 id="支持的类型"><a href="#支持的类型" class="headerlink" title="支持的类型"></a>支持的类型</h2><p>Realm支持以下基本类型：<code>bool</code>, <code>int</code>, <code>float</code>, <code>double</code>, <code>string</code>, <code>data</code> 和 <code>date</code>。</p>
<ul>
<li><code>bool</code> 属性对应 JavaScript <code>Bool</code> 类型</li>
<li><code>int</code>, <code>float</code> 和 <code>double</code> 属性对应 JavaScript <code>Number</code> 类型. 另外 ‘int’ 和 ‘double’ 以64位存储； float 以32位存储.</li>
<li><code>string</code> 属性对应 <code>String</code> 类型</li>
<li><code>data</code> 属性对应 <code>ArrayBuffer</code> 类型</li>
<li><code>date</code> 属性对应 <code>Date</code> 类型</li>
</ul>
<p>指定一个基础类型的简写，你只需要指定一个类型而不需要指定一个含有单个键值对的对象：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const CarSchema = &#123;</span><br><span class="line">  name: &apos;Car&apos;,</span><br><span class="line">  properties: &#123;</span><br><span class="line">    // 以下属性类型是等价的</span><br><span class="line">    make:   &#123;type: &apos;string&apos;&#125;,</span><br><span class="line">    model: &apos;string&apos;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p>
<h2 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h2><h3 id="对一关系"><a href="#对一关系" class="headerlink" title="对一关系"></a>对一关系</h3><p>通过将你关联对象的<code>name</code>属性作为主对象的属性类型，来形成对一关系：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> PersonSchema = &#123;</span><br><span class="line">  name: <span class="string">'Person'</span>,</span><br><span class="line">  properties: &#123;</span><br><span class="line">    <span class="comment">// 以下的两个属性是等价的</span></span><br><span class="line">    car: &#123;<span class="attr">type</span>: <span class="string">'Car'</span>&#125;,</span><br><span class="line">    van: <span class="string">'Car'</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p></p>
<p>当时用了对象作为属性之后，你需要确保所有关联的对象已经在开启Realm的时候声明。<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 因为PersonSchema包含了一个类型为Car的属性，所以CarSchema也需要在此声明</span></span><br><span class="line">Realm.open(&#123;<span class="attr">schema</span>: [CarSchema, PersonSchema]&#125;)</span><br><span class="line">  .then(<span class="comment">/* ... */</span>);</span><br></pre></td></tr></table></figure><p></p>
<p>当访问对象属性的时候，你可以以普通的属性访问语法访问对象属性内部的属性：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">realm.write(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> nameString = person.car.name;</span><br><span class="line">  person.car.miles = <span class="number">1100</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// create a new Car by setting the property to valid JSON</span></span><br><span class="line">  person.van = &#123;<span class="attr">make</span>: <span class="string">'Ford'</span>, <span class="attr">model</span>: <span class="string">'Transit'</span>&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// set both properties to the same car instance</span></span><br><span class="line">  person.car = person.van;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p></p>
<h3 id="对多关系"><a href="#对多关系" class="headerlink" title="对多关系"></a>对多关系</h3><p>对于对多属性，你必须声明这个属性类型为<code>list</code>类型，并且必须同时声明这个<code>list</code>的<code>item</code>类型：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> PersonSchema = &#123;</span><br><span class="line">  name: <span class="string">'Person'</span>,</span><br><span class="line">  properties: &#123;</span><br><span class="line">    cars: &#123;<span class="attr">type</span>: <span class="string">'list'</span>, <span class="attr">objectType</span>: <span class="string">'Car'</span>&#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p>
<p>当访问<code>list</code>属性的时候，将会返回<code>List</code>对象。<code>List</code>对象拥有跟正常Javascript对象类似的方法（需要注意的是：<code>typeof List</code>仍旧是对象类型，而不是Array）。跟普通JS数组对象最大的区别是，对<code>List</code>的任意更改都会自动持久化到<code>Realm</code>下。另外，<code>List</code>属于底层对象的基础属性，你只能通过从主对象访问属性来获取<code>List</code>实例，它们不允许被手动创建。<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> carList = person.cars;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 增加新的car到列表</span></span><br><span class="line">realm.write(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  carList.push(&#123;<span class="attr">make</span>: <span class="string">'Honda'</span>, <span class="attr">model</span>: <span class="string">'Accord'</span>, <span class="attr">miles</span>: <span class="number">100</span>&#125;);</span><br><span class="line">  carList.push(&#123;<span class="attr">make</span>: <span class="string">'Toyota'</span>, <span class="attr">model</span>: <span class="string">'Prius'</span>, <span class="attr">miles</span>: <span class="number">200</span>&#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> secondCar = carList[<span class="number">1</span>].model;  <span class="comment">// 通过数组索引访问</span></span><br></pre></td></tr></table></figure><p></p>
<h3 id="反向关系"><a href="#反向关系" class="headerlink" title="反向关系"></a>反向关系</h3><p>关系是单向的。所以，当一个对多属性<code>Person.dogs</code>关联了<code>Dog</code>实例，一个对一属性<code>Dog.owner</code>关联了<code>Person</code>的同时，这两个联系对于互相来说是独立的。即添加一个<code>Dog</code>到<code>Person</code>实例的<code>dogs</code>属性的时候，并不会自动更新dogs的<code>owner</code>属性。因为，手动关联关系对会造成容易出错、更加复杂化并且会产生重复信息的问题，所以Realm提供了链接对象属性来表示这些反向关系。</p>
<p>当链接对象属性的时候，你可以通过那个特定的属性，获取关联的所有对象。比如：一个<code>dog</code>对象可以有一个<code>owners</code>属性，其中有一个包含了这个<code>dog</code>对象的<code>dogs</code>属性。以上可以通过指定<code>owners</code>的属性类型为<code>linkingObjects</code>并且关联对象为<code>Person</code>对象来达成目的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> PersonSchema = &#123;</span><br><span class="line">  name: <span class="string">'Person'</span>,</span><br><span class="line">  properties: &#123;</span><br><span class="line">    dogs: &#123;<span class="attr">type</span>: <span class="string">'list'</span>, <span class="attr">objectType</span>: <span class="string">'Dog'</span>&#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> DogSchema = &#123;</span><br><span class="line">  name:<span class="string">'Dog'</span>,</span><br><span class="line">  properties: &#123;</span><br><span class="line">    owners: &#123;<span class="attr">type</span>: <span class="string">'linkingObjects'</span>, <span class="attr">objectType</span>: <span class="string">'Person'</span>, <span class="attr">property</span>: <span class="string">'dogs'</span>&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个<code>linkingObjects</code>属性可以关联到一个<code>List</code>属性（对多关系）或者一个<code>Object</code>属性（对一关系）：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ShipSchema = &#123;</span><br><span class="line">  name: <span class="string">'Ship'</span>,</span><br><span class="line">  properties: &#123;</span><br><span class="line">    captain: <span class="string">'Captain'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> CaptainSchema = &#123;</span><br><span class="line">  name: <span class="string">'Captain'</span>,</span><br><span class="line">  properties: &#123;</span><br><span class="line">    ships: &#123;<span class="attr">type</span>: <span class="string">'linkingObjects'</span>, <span class="attr">objectType</span>: <span class="string">'Ship'</span>, <span class="attr">property</span>: <span class="string">'captain'</span>&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p>
<p>当访问<code>linkingObjects</code>属性的时候，一个<code>Results</code>对象将会被返回，目前为止，这个对象完全支持查询和排序。<code>linkingObject</code>属性属于对象要求的基本属性，所以不能被设置值或者直接操作。它们会在一个事务完成后自动更新。</p>
<p><em>不通过<code>schema</code>访问<code>linkingObjects</code></em>：如果你在开启realm的时候，没有声明schema，举个例子，在一个 <a href="Realm Functions">Realm Functions的回调</a>里面，你可以调用一个对象实例的<code>linkingObjects(objectType, property)</code>方法获取<code>linkingObjects</code>属性。<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> captain = realm.objectForPrimaryKey(<span class="string">'Captain'</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">let</span> ships = captain.linkingObjects(<span class="string">'Ship'</span>, <span class="string">'captain'</span>);</span><br></pre></td></tr></table></figure><p></p>
<h2 id="Optional-属性"><a href="#Optional-属性" class="headerlink" title="Optional 属性"></a>Optional 属性</h2><p>在你的属性定义中，一个属性可以通过<code>optional</code>标记被声明可选或者必填：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> PersonSchema = &#123;</span><br><span class="line">  name: <span class="string">'Person'</span>,</span><br><span class="line">  properties: &#123;</span><br><span class="line">    name:     &#123;<span class="attr">type</span>: <span class="string">'string'</span>&#125;,               <span class="comment">// 必填属性</span></span><br><span class="line">    birthday: &#123;<span class="attr">type</span>: <span class="string">'date'</span>, <span class="attr">optional</span>: <span class="literal">true</span>&#125;, <span class="comment">// 可选属性</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对象属性被设置为可选（无法变更）</span></span><br><span class="line">    car:      &#123;<span class="attr">type</span>: <span class="string">'Car'</span>&#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> realm = <span class="keyword">new</span> Realm(&#123;<span class="attr">schema</span>: [PersonSchema, CarSchema]&#125;);</span><br><span class="line"></span><br><span class="line">realm.write(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 在创建的时候，可选属性可以被设置值为null或者undefind</span></span><br><span class="line">  <span class="keyword">let</span> charlie = realm.create(<span class="string">'Person'</span>, &#123;</span><br><span class="line">    name: <span class="string">'Charlie'</span>,</span><br><span class="line">    birthday: <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">1995</span>, <span class="number">11</span>, <span class="number">25</span>),</span><br><span class="line">    car: <span class="literal">null</span>,</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 可选属性可以被设置值为`null`或者`undefind`</span></span><br><span class="line">  <span class="comment">// 或者一个新的非null的值</span></span><br><span class="line">  charlie.birthday = <span class="literal">undefined</span>;</span><br><span class="line">  charlie.car = &#123;<span class="attr">make</span>: <span class="string">'Honda'</span>, <span class="attr">model</span>: <span class="string">'Accord'</span>, <span class="attr">miles</span>: <span class="number">10000</span>&#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p></p>
<p>可以从上面看出对象属性总是允许可选的，并不需要一个<code>optional</code>标记。List属性不能被声明为可选并且值不能设置为null。你可以通过设置或者初始化一个空的list来清空它。</p>
<h3 id="默认值设置"><a href="#默认值设置" class="headerlink" title="默认值设置"></a>默认值设置</h3><p>在属性定义中，可以通过设置<code>default</code>标记来设置默认值。在对象创建期间，不给属性设置值将会使用默认值来填充。<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> CarSchema = &#123;</span><br><span class="line">  name: <span class="string">'Car'</span>,</span><br><span class="line">  properties: &#123;</span><br><span class="line">    make:  &#123;<span class="attr">type</span>: <span class="string">'string'</span>&#125;,</span><br><span class="line">    model: &#123;<span class="attr">type</span>: <span class="string">'string'</span>&#125;,</span><br><span class="line">    drive: &#123;<span class="attr">type</span>: <span class="string">'string'</span>, <span class="attr">default</span>: <span class="string">'fwd'</span>&#125;,</span><br><span class="line">    miles: &#123;<span class="attr">type</span>: <span class="string">'int'</span>,    <span class="attr">default</span>: <span class="number">0</span>&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">realm.write(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 因为`miles`未被填写，所以会被默认设置为`0`</span></span><br><span class="line">  <span class="comment">// 因为`drive`被指定值，它将会覆盖默认值</span></span><br><span class="line">  realm.create(<span class="string">'Car'</span>, &#123;<span class="attr">make</span>: <span class="string">'Honda'</span>, <span class="attr">model</span>: <span class="string">'Accord'</span>, <span class="attr">drive</span>: <span class="string">'awd'</span>&#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p></p>
<h3 id="索引属性"><a href="#索引属性" class="headerlink" title="索引属性"></a>索引属性</h3><p>你可以在属性定义中增加<code>indexed</code>标记来使得整个属性被索引。支持<code>int</code>, <code>string</code>和<code>bool</code>类型的属性。<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> BookSchema = &#123;</span><br><span class="line">  name: <span class="string">'Book'</span>,</span><br><span class="line">  properties: &#123;</span><br><span class="line">    name: &#123; <span class="attr">type</span>: <span class="string">'string'</span>, <span class="attr">indexed</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">    price: <span class="string">'float'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p></p>
<p>索引一个属性以插入的更慢为代价，非常大的提升了查询的速度。</p>
<h3 id="主键"><a href="#主键" class="headerlink" title="主键"></a>主键</h3><p>在对象模型内，可以对<code>int</code>和<code>string</code>属性指定一个<code>primaryKey</code>属性。声明一个主键，可以使得查询和更新更有效率，并且将强制值唯一性。一旦一个带有主键的对象加入到Realm中，则这个主键无法变更。<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> BookSchema = &#123;</span><br><span class="line">  name: <span class="string">'Book'</span>,</span><br><span class="line">  primaryKey: <span class="string">'id'</span>,</span><br><span class="line">  properties: &#123;</span><br><span class="line">    id:    <span class="string">'int'</span>,    <span class="comment">// 主键</span></span><br><span class="line">    title: <span class="string">'string'</span>,</span><br><span class="line">    price: <span class="string">'float'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p></p>
<p>主键属性将会自动被索引。</p>
<h1 id="写入"><a href="#写入" class="headerlink" title="写入"></a>写入</h1><p>在Realm内更改对象内容——创建、更新和删除——必须放在一个<code>write()</code>的事务块里面。需要注意的是写事务是一个不可忽略的开销；在你的代码中应该尽量减少<code>write</code>事务块。</p>
<h2 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h2><p>使用<code>create</code>方法创建对象：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  realm.write(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    realm.create(<span class="string">'Car'</span>, &#123;<span class="attr">make</span>: <span class="string">'Honda'</span>, <span class="attr">model</span>: <span class="string">'Accord'</span>, <span class="attr">drive</span>: <span class="string">'awd'</span>&#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"Error on creation"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p>
<p>注意：在<code>write()</code>内抛出任意异常都会取消事务。<code>try/catch</code>块并不会在所有样例代码上出现，但是捕获异常这是一个好的习惯。</p>
<h3 id="内嵌对象"><a href="#内嵌对象" class="headerlink" title="内嵌对象"></a>内嵌对象</h3><p>如果一个对象有一个对象属性，通过特定的JSON值，会递归创建那些属性值。<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">realm.write(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  realm.create(<span class="string">'Person'</span>, &#123;</span><br><span class="line">    name: <span class="string">'Joe'</span>,</span><br><span class="line">    <span class="comment">// nested objects are created recursively</span></span><br><span class="line">    car: &#123;<span class="attr">make</span>: <span class="string">'Honda'</span>, <span class="attr">model</span>: <span class="string">'Accord'</span>, <span class="attr">drive</span>: <span class="string">'awd'</span>&#125;,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p></p>
<h3 id="更新对象"><a href="#更新对象" class="headerlink" title="更新对象"></a>更新对象</h3><h4 id="类型更新"><a href="#类型更新" class="headerlink" title="类型更新"></a>类型更新</h4><p>在写事务中你可以通过设置属性值来更新对象：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">realm.write(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  car.miles = <span class="number">1100</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p></p>
<h4 id="根据主键创建和更新对象"><a href="#根据主键创建和更新对象" class="headerlink" title="根据主键创建和更新对象"></a>根据主键创建和更新对象</h4><p>如果你的模型类包含有主键，你可以让Realm智能的根据主键来创建和更新对象。这个功能可以通过在<code>create</code>方法传递第三个值为<code>true</code>来开启。<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">realm.write(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 创建一个book对象</span></span><br><span class="line">  realm.create(<span class="string">'Book'</span>, &#123;<span class="attr">id</span>: <span class="number">1</span>, <span class="attr">title</span>: <span class="string">'Recipes'</span>, <span class="attr">price</span>: <span class="number">35</span>&#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据主键id更新price值</span></span><br><span class="line">  realm.create(<span class="string">'Book'</span>, &#123;<span class="attr">id</span>: <span class="number">1</span>, <span class="attr">price</span>: <span class="number">55</span>&#125;, <span class="literal">true</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p></p>
<p>在上述的案例中，因为已经存在了一个id值为1的对象并且我们传递了<code>true</code>值给第三个参数，那么<code>price</code>属性将会被更新，而不是尝试创建一个新的对象。由于<code>name</code>属性被省略，对象保留此属性的原始值。注意：当用主键创建或者更新对象的时候，主键必须被指定。</p>
<h3 id="删除对象"><a href="#删除对象" class="headerlink" title="删除对象"></a>删除对象</h3><p>在<code>write</code>事务块内，对象可以通过<code>delete</code>方法删除。<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">realm.write(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// Create a book object</span></span><br><span class="line">  <span class="keyword">let</span> book = realm.create(<span class="string">'Book'</span>, &#123;<span class="attr">id</span>: <span class="number">1</span>, <span class="attr">title</span>: <span class="string">'Recipes'</span>, <span class="attr">price</span>: <span class="number">35</span>&#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Delete the book</span></span><br><span class="line">  realm.delete(book);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Delete multiple books by passing in a `Results`, `List`,</span></span><br><span class="line">  <span class="comment">// or JavaScript `Array`</span></span><br><span class="line">  <span class="keyword">let</span> allBooks = realm.objects(<span class="string">'Book'</span>);</span><br><span class="line">  realm.delete(allBooks); <span class="comment">// Deletes all books</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p></p>
<h1 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h1><p>查询允许你可以通过Realm获取单类型对象，并且对这些对象进行过滤和排序。在Realm中所有的查询（包括查询和属性获取）都是懒加载形式。数据只会在对象或者属性被访问的时候才会读取。这样做可以让你在请求大数据量的时候有个好的加载体验。当查询的时候，将会返回<code>Results</code>对象。<code>Results</code>只是你的数据的一个简单展示，并且是不可变更的。</p>
<p>最基础的获取数据的方式是通过在<code>realm</code>中使用<code>objects</code>方法，以此获取到所给类型的所有对象：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> dogs = realm.objects(<span class="string">'Dog'</span>); <span class="comment">// 从Realm中获取所有的'Dog'</span></span><br></pre></td></tr></table></figure><p></p>
<h2 id="过滤"><a href="#过滤" class="headerlink" title="过滤"></a>过滤</h2><p>你可以通过调用<code>filtered</code>方法附带查询字符串，来获取一个被过滤的结果对象<code>Results</code>。</p>
<p>举个例子：以下的代码（附带了<code>color</code>为<code>tan</code>和<code>name</code>以<code>B</code>开头）将会改变我们之前样例查询所有Dogs的结果：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> dogs = realm.objects(<span class="string">'Dog'</span>);</span><br><span class="line"><span class="keyword">let</span> tanDogs = dogs.filtered(<span class="string">'color = "tan" AND name BEGINSWITH "B"'</span>);</span><br></pre></td></tr></table></figure><p></p>
<p>目前为止，在查询语句中，只有<code>NSPredicate</code>语法的子集才被支持。基本比较符<code>==</code>, <code>!=</code>, <code>&gt;</code>, <code>&gt;=</code>, <code>&lt;</code> 和 <code>&lt;=</code>支持数字类属性。<code>==</code>, <code>BEGINSWITH</code>, <code>ENDSWITH</code>, 和 <code>CONTAINS</code>支持字符类属性。字符串类的比较可以通过添加<code>[c]</code>到比较符号（<code>==[c]</code>, <code>BEGINSWITH[c]</code>等等）来忽略大小写。过滤关联的属性或者孩子对象，可以通过指定一个比如<code>car.color == &#39;blue&#39;</code>的值路径来进行过滤。</p>
<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p><code>Results</code>允许你指定基于单个或多个属性的排序标准和顺序。比如，下面的代码对样例上的返回结果根据<code>miles</code>做了数字排序。<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> hondas = realm.objects(<span class="string">'Car'</span>).filtered(<span class="string">'make = "Honda"'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据 mileage 排序 Honda </span></span><br><span class="line"><span class="keyword">let</span> sortedHondas = hondas.sorted(<span class="string">'miles'</span>);</span><br></pre></td></tr></table></figure><p></p>
<p>注意：<code>Results</code>的排序只有在查询排序时才能保持一致。为了行能考虑，插入的顺序并不被保证保留。</p>
<h2 id="自动更新结果集"><a href="#自动更新结果集" class="headerlink" title="自动更新结果集"></a>自动更新结果集</h2><p><code>Results</code>实例是实时的，自动更新视图到底层数据的，这意味着结果永远不必重新获取。修改查询的对象，将会立即反应到结果中。<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> hondas = realm.objects(<span class="string">'Car'</span>).filtered(<span class="string">'make = "Honda"'</span>);</span><br><span class="line"><span class="comment">// hondas.length == 0</span></span><br><span class="line"></span><br><span class="line">realm.write(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  realm.create(<span class="string">'Car'</span>, &#123;<span class="attr">make</span>: <span class="string">'Honda'</span>, <span class="attr">model</span>: <span class="string">'RSX'</span>&#125;);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// hondas.length == 1</span></span><br></pre></td></tr></table></figure><p></p>
<p>这对所有的<code>Results</code>实例都起作用，包括那些返回后又调用了<code>objects</code>, <code>filtered</code> 和 <code>sorted</code>方法。</p>
<p><code>Results</code> 不止保证Realm更快更有效率，且使得你的代码更简单更灵活。比如，如果你的试图依赖查询结果，你可以存储<code>Results</code>到一个属性并且不需要在每次访问这个视图前刷新试图的数据。</p>
<p>您可以订阅<a href="#通知">notifications</a>，以了解Realm数据的更新时间，指明应用程序的UI应该如何刷新，而无需重新获取结果<code>Results</code>。</p>
<h2 id="限制结果"><a href="#限制结果" class="headerlink" title="限制结果"></a>限制结果</h2><p>大多数的数据库技术都提供有分页的功能（例如MySQL的<code>LIMIT</code>关键字）。这个通常是为了避免非必要的大量磁盘读取或者一次性拉取太多的结果。</p>
<p>因为Realm的懒查询，做这种分页行为并不必要，因为Realm只会在真正访问这个属性的时候才会从<code>Results</code>实例中加载对象。</p>
<p>如果为了UI相关或者其他实现的理由需要结果集的某些特定的子结果集，就跟获取<code>Results</code>对象一样简单，就是指读出你想要的对象即可。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let cars = realm.objects(&apos;Car&apos;);</span><br><span class="line"></span><br><span class="line">// 获取开头5个car对象</span><br><span class="line">let firstCars = cars.slice(0, 5);</span><br></pre></td></tr></table></figure><p></p>
<h1 id="Realms"><a href="#Realms" class="headerlink" title="Realms"></a>Realms</h1><h2 id="打开Realms"><a href="#打开Realms" class="headerlink" title="打开Realms"></a>打开Realms</h2><p>打开Realm只需要通过调用<code>Realm</code>类中的静态<code>open</code>方法来执行。传递一个配置对象。我们已经在使用包含<code>schema</code>键的配置对象中看到过这个例子：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 获取支持我们对象的默认Realm</span><br><span class="line">Realm.open(&#123;schema: [Car, Person]&#125;)</span><br><span class="line">  .then(realm =&gt; &#123;</span><br><span class="line">    // ...use the realm instance here</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(error =&gt; &#123;</span><br><span class="line">    // Handle the error here if something went wrong</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p></p>
<p>关于配置对象完整细节，看这个<a href="https://realm.io/docs/javascript/latest/api/Realm.html#~Configuration" target="_blank" rel="noopener">API文档</a>。其他更多配置项，除了<code>schema</code>，还有：</p>
<ul>
<li>path: 指定一个给<a href="#其他的Realms">另一个Realm</a></li>
<li>migration: 一个<a href="#迁移函数">迁移函数</a></li>
<li>sync：一个<a href="#同步对象">同步对象</a>，用来同步打开与Realm对象服务器同步的Realm</li>
<li>inMemory: Realm将会在内存中打开，对象不会持久化到硬盘；一旦最后的Realm实例关闭，所有的对象将会不复存在</li>
</ul>
<h2 id="默认Realm"><a href="#默认Realm" class="headerlink" title="默认Realm"></a>默认Realm</h2><p>在之前的所有例子中，你可能已经注意到路径参数已被省略。在这种情况下，将会使用默认的Realm路径。但是你可以通过使用<code>Realm.defaultPath</code>这个全局属性来访问或者变更默认路径。</p>
<h2 id="其他的Realms"><a href="#其他的Realms" class="headerlink" title="其他的Realms"></a>其他的Realms</h2><p>有时候在不同的路径保存保存多个Realms是有用的。举个例子，除了你的主要Realm之外，你还可能需要将你的数据和应用打包在同一个Realm文件中。你可以通过初始化Realm的时候指定<code>path</code>参数来执行此操作。所有的路径都是相对于你的应用的可写目录：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在另一个位置打开Realm</span></span><br><span class="line">Realm.open(&#123;</span><br><span class="line">  path: <span class="string">'anotherRealm.realm'</span>,</span><br><span class="line">  schema: [CarSchema]</span><br><span class="line">&#125;).then(<span class="comment">/* ... */</span>);</span><br></pre></td></tr></table></figure><p></p>
<h2 id="Schema版本"><a href="#Schema版本" class="headerlink" title="Schema版本"></a>Schema版本</h2><p>另一个在打开Realm时可用的参数是<code>schemaVersion</code>。如果不设置，则默认为<code>0</code>。在使用与之前包含对象不同的Realm初始化现有Realm的时候，你需要指定<code>schemaVersion</code>的值。如果schema被更新了，但是没有指定<code>schemaVersion</code>，则会抛出异常：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const PersonSchema = &#123;</span><br><span class="line">  name: &apos;Person&apos;,</span><br><span class="line">  properties: &#123;</span><br><span class="line">    name: &apos;string&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// schemaVersion 默认值为0</span><br><span class="line">Realm.open(&#123;schema: [PersonSchema]&#125;);</span><br></pre></td></tr></table></figure><p></p>
<p>如果你在之后这么做：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const UpdatedPersonSchema = &#123; </span><br><span class="line">  // schema的名称是相同的，所有之前在Realm内的Person对象将会被更新</span><br><span class="line">  name: ‘Person’, </span><br><span class="line">  properties: &#123; </span><br><span class="line">    name: ‘string’, </span><br><span class="line">    dog: ‘Dog’ // 新属性</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 这将会抛出异常，因为schema已经被改变了但是schemaVersion未被指定</span><br><span class="line">Realm.open(&#123;schema: [UpdatedPersonSchema]&#125;);</span><br><span class="line"></span><br><span class="line">// 这个将会成功，并且更新schema为新的schema</span><br><span class="line">Realm.open(&#123;schema: [UpdatedPersonSchema], schemaVersion: 1&#125;);</span><br></pre></td></tr></table></figure><p></p>
<p>如果你希望取得一个Realm当前的schema版本，你可以使用<code>Realm.schemaVersion</code>方法。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const currentVersion = Realm.schemaVersion(Realm.defaultPath);</span><br></pre></td></tr></table></figure><p></p>
<h2 id="同步打开Realms"><a href="#同步打开Realms" class="headerlink" title="同步打开Realms"></a>同步打开Realms</h2><p>你可以通过简单的调用构造函数并将配置信息传递给它来创建一个realm的实例。这通常不被推荐，因为它阻塞了程序可能潜在的产生耗时操作，特别是当有schema迁移需要进行或者realm是<a href="#同步">同步</a>的，并且你不希望冒在数据完全下载之前修改它的风险。</p>
<p>如果你仍旧想要这么做，形式很简单：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const realm = new Realm(&#123;schema: [PersonSchema]&#125;);</span><br><span class="line"></span><br><span class="line">// 你现在可以访问realm实例了</span><br><span class="line">realm.write(/* ... */);</span><br></pre></td></tr></table></figure><p></p>
<p>注意：如果一个realm只有只读权限，那么你必须以异步的方式打开它。因为使用上述形式同步打开一个只读的realm，将会一个错误。</p>
<h1 id="迁移"><a href="#迁移" class="headerlink" title="迁移"></a>迁移</h1><p>在使用数据库的时候，你的数据模型可能随着时间的变化随时发生改变。举个例子，假设我们有一个<code>Person</code>的模型：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const PersonSchema = &#123;</span><br><span class="line">  name: &apos;Person&apos;,</span><br><span class="line">  properties: &#123;</span><br><span class="line">    firstName: &apos;string&apos;,</span><br><span class="line">    lastName: &apos;string&apos;,</span><br><span class="line">    age: &apos;int&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p>
<p>我们想要更新数据模型，只需要一个<code>name</code>属性而不是将它拆分成姓氏和名称两个属性。为此，我们只需要将schema更改成以下内容：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const PersonSchema = &#123;</span><br><span class="line">  name: &apos;Person&apos;,</span><br><span class="line">  properties: &#123;</span><br><span class="line">    name: &apos;string&apos;,</span><br><span class="line">    age: &apos;int&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p>
<p>在这点上，如果你以前的模型版本上保存了任意的数据，新的代码与Realm存储在磁盘上的旧数据将不匹配。当这种情况发生的时候，当你用新的schema打开之前的Realm的时候，将会抛出一个异常，除非你进行数据迁移。</p>
<h2 id="进行迁移"><a href="#进行迁移" class="headerlink" title="进行迁移"></a>进行迁移</h2><p>你可以通过更新<a href="schema版本">schemaVersion</a>并定义一个可选的<code>migration</code>函数来定义一个迁移和与之关联的schema版本。你的迁移函数逻辑需要能够支持将之前的schema版本的数据模型转化为新schema的数据模型。当打开<code>Realm</code>的时候，只有当需要迁移的时候，才会将<code>Realm</code>更新到给定版本的schema。</p>
<p>如果没有提供迁移功能，则当更新到新的<code>schemaVersion</code>的时候，新的属性将会添加而旧的属性将会从数据库删除。如果您需要在升级版本时更新旧的或者填充的新属性，那么可以在迁移功能中执行此操作。例如，假设我们想要迁移早先声明的<code>Person</code>模型，你可以使用旧的<code>firstName</code>和<code>lastName</code>的数据填充新的<code>name</code>：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Realm.open(&#123;</span><br><span class="line">  schema: [PersonSchema],</span><br><span class="line">  schemaVersion: <span class="number">1</span>,</span><br><span class="line">  migration: <span class="function">(<span class="params">oldRealm, newRealm</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 只有当schemaVersion更新为1的时候才应用这个更改</span></span><br><span class="line">    <span class="keyword">if</span> (oldRealm.schemaVersion &lt; <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> oldObjects = oldRealm.objects(<span class="string">'Person'</span>);</span><br><span class="line">      <span class="keyword">const</span> newObjects = newRealm.objects(<span class="string">'Person'</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 循环所有的对象，并且在新的schema中设置name属性</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; oldObjects.length; i++) &#123;</span><br><span class="line">        newObjects[i].name = oldObjects[i].firstName + <span class="string">' '</span> + oldObjects[i].lastName;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;).then(<span class="function"><span class="params">realm</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> fullName = realm.objects(<span class="string">'Person'</span>)[<span class="number">0</span>].name;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p></p>
<p>一旦你迁移完全成功，所有Realm对象都可以像往常一样被使用。</p>
<h2 id="线性迁移"><a href="#线性迁移" class="headerlink" title="线性迁移"></a>线性迁移</h2><p>在使用上述迁移模式的时候，你可能会在多版本的迁移上出现问题。比方用户跳过应用程序的更新，并且在跳过的版本中该属性已被更改多次，则发生这种情况可能会发生。在这种情况下，您可能需要编辑旧的迁移代码，以将数据从旧的schema下更新到最新的schema。</p>
<p>可以通过顺序运行多个迁移来避免这个问题，确保数据库根据版本依次升级并且与之关联的每个升级迁移都被执行。按照这个步骤的话，则旧的迁移代码不必被修改，尽管你需要为将来的使用保存所有旧的schema和迁移语句。一个类似的例子：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> schemas = [</span><br><span class="line">  &#123; <span class="attr">schema</span>: schema1, <span class="attr">schemaVersion</span>: <span class="number">1</span>, <span class="attr">migration</span>: migrationFunction1 &#125;,</span><br><span class="line">  &#123; <span class="attr">schema</span>: schema2, <span class="attr">schemaVersion</span>: <span class="number">2</span>, <span class="attr">migration</span>: migrationFunction2 &#125;,</span><br><span class="line">  ...</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一个schema将要更新的是当前的schema版本</span></span><br><span class="line"><span class="comment">// 因为第一个schema是在我们的数组中的第一个位置</span></span><br><span class="line"><span class="keyword">let</span> nextSchemaIndex = Realm.schemaVersion(Realm.defaultPath);</span><br><span class="line"><span class="keyword">while</span> (nextSchemaIndex &lt; schemas.length) &#123;</span><br><span class="line">  <span class="keyword">const</span> migratedRealm = <span class="keyword">new</span> Realm(schemas[nextSchemaIndex++]);</span><br><span class="line">  migratedRealm.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用最新的schema打开Realm</span></span><br><span class="line">Realm.open(schemas[schemas.length<span class="number">-1</span>]);</span><br></pre></td></tr></table></figure><p></p>
<h1 id="通知"><a href="#通知" class="headerlink" title="通知"></a>通知</h1><p><code>Realm</code>, <code>Results</code>和<code>List</code>对象提供了<code>addListener</code>方法来注册通知回调。无论对象什么时候更新，数据更改通知的回调都会被触发。</p>
<p>有两种通知方式：“Realm 通知”（当写事务被提交后简单的回调会被通知）和“集合通知”（更复杂的回调可以在插入、删除和更新的时候接收到更改的元数据）。</p>
<p>另外，此外，专业版和企业版提供事件处理通知。 阅读“Realm移动平台”了解更多信息。</p>
<h2 id="Realm通知"><a href="#Realm通知" class="headerlink" title="Realm通知"></a>Realm通知</h2><p>Realm实例在每次写事务提交后都会发送通知给其他实例。注册通知：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateUI</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听Realm通知</span></span><br><span class="line">realm.addListener(<span class="string">'change'</span>, updateUI);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ..之后删除监听</span></span><br><span class="line">realm.removeListener(<span class="string">'change'</span>, updateUI);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ..或者删除所有监听</span></span><br><span class="line">realm.removeAllListeners();</span><br></pre></td></tr></table></figure><p></p>
<h2 id="集合通知"><a href="#集合通知" class="headerlink" title="集合通知"></a>集合通知</h2><p>集合通知包含了描述在细粒度级别上发生了哪些更改的信息。这包括自上次通知以后，那些被插入、删除或者修改过的对象的索引。集合通知是异步推送：首先使用初始结果，然后在任何修改集合中的任何对象的写事务之后，从集合中删除对象，或向集合中添加新对象。</p>
<p>当这些改变发生的时候，<code>addListener</code>的通知回调函数将接收到两个参数。第一个是集合已经被更改，第二个是<code>changes</code>对象，包含了受删除、插入和修改影响的集合索引。</p>
<p>前两项，删除和插入，每当对象加入集合或从集合中被删除的时候，都会记录索引。每当你添加对象到Realm或者将其从Realm中删除的时候，都需要考虑到这点。</p>
<p>// TODO 量有点大，之后的内容待完善</p>
      
    </div>

  </div>

  
  <div class="article-copyright">
      <div class="copyright"><p><span>本文标题:</span><a href="/Realm文档翻译.html">【翻译】Realm Javascript 1.12.0文档</a></p><p><span>文章作者:</span><a href="/" title="访问 WhatAKitty 的个人博客">WhatAKitty</a></p><p><span>发布时间:</span>2017年10月14日 - 12时12分</p><p><span>最后更新:</span>2017年11月11日 - 17时03分</p><p><span>原始链接:</span><a href="/Realm文档翻译.html" title="【翻译】Realm Javascript 1.12.0文档">https://xuqiang.me/Realm文档翻译.html</a> <span class="btn" data-clipboard-text="原文: https://xuqiang.me/Realm文档翻译.html　　作者: WhatAKitty" title="点击复制文章链接"><i class="fa fa-clipboard"></i></span></p><p><span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/3.0/cn/" title="中国大陆 (CC BY-NC-SA 3.0 CN)">"署名-非商用-相同方式共享 3.0"</a> 转载请保留原文链接及作者。</p></div><br><br><style type="text/css">.copyright p .btn{margin-left:1em}.copyright:hover p .btn::after{content:"复制"}.copyright p .btn:hover{color:gray;cursor:pointer}</style>
  </div>
  

  

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/文档翻译/">文档翻译</a>, <a href="/categories/文档翻译/RealmJS/">RealmJS</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/realm/">realm</a><a href="/tags/node/">node</a><a href="/tags/react-native/">react-native</a><a href="/tags/react/">react</a><a href="/tags/翻译/">翻译</a><a href="/tags/javascript/">javascript</a>
    </span>
    

    </div>

    
    <div class="article-meta pull-right">
      <span style="display:inline-block;width:83px">
        <a style="float:left;text-decoration:none" target="_blank" href="https://www.banquanyin.com/u/101709260007755">
          <img src="https://s1.banquanyin.com/c/icon-yin-24.png" title="更多授权" style="width:inherit">
        </a>
        <a target="_blank" href="https://101709260007755.bqy.mobi">
          <img src="https://s1.banquanyin.com/c/icon-auth-cr-24.png" title="获取授权" style="width:inherit">
        </a>
      </span>
    </div>
    

    
  </div>

  
    <div style="text-align:center;margin-top:80px">
      <div id="cyReward" role="cylabs" data-use="reward" sid="81e8b8afaa5e57e5af992e0f03ee01ce" cid="1"></div>
    </div>
  

</article>


  <div id="SOHUCS" sid="81e8b8afaa5e57e5af992e0f03ee01ce"></div><script type="text/javascript">!function(){var t="1243e90ae1a56c027241ecf5b99daeda";(window.innerWidth||document.documentElement.clientWidth)<960?window.document.write('<script id="changyan_mobile_js" charset="utf-8" type="text/javascript" src="https://changyan.sohu.com/upload/mobile/wap-js/changyan_mobile.js?client_id=cytdcyLLd&conf='+t+'"><\/script>'):function(t,e){var n=document.getElementsByTagName("head")[0]||document.head||document.documentElement,a=document.createElement("script");a.setAttribute("type","text/javascript"),a.setAttribute("charset","UTF-8"),a.setAttribute("src","https://changyan.sohu.com/upload/changyan.js"),"function"==typeof e&&(window.attachEvent?a.onreadystatechange=function(){var t=a.readyState;"loaded"!==t&&"complete"!==t||(a.onreadystatechange=null,e())}:a.onload=e),n.appendChild(a)}(0,function(){window.changyan.api.config({appid:"cytdcyLLd",conf:t})})}()</script><script type="text/javascript" charset="utf-8" src="https://changyan.itc.cn/js/lib/jquery.js"></script><script type="text/javascript" charset="utf-8" src="https://changyan.sohu.com/js/changyan.labs.https.js?appid=cytdcyLLd"></script>
    </main>

    <footer class="site-footer"><p class="site-info">Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a><br>&copy; 2018 WhatAKitty<br><a href="https://blog.whatakitty.com">浙ICP备15019585号</a> <a target="_blank" href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=33010602008839" style="display:block;line-height:20px"><span style="display:inline-block;line-height:20px;vertical-align:middle"><img src="https://static.xuqiang.me/public/images/beian.png" style="width:20px;height:20px"></span><span style="display:inline-block;height:20px;line-height:20px;margin:0 0 0 5px">浙公网安备 33010602008839号</span></a></p></footer>
    
    <script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?1d4c4cd810512d2fddb7187b7939389a";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script></div></div></body></html>
